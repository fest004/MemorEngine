{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"memor/","title":"COMPASS","text":"<p>Control, Orient, Manoeuvre, Path Align and Stabilise Spaceflight</p> <p>Welcome to the documentation for project COMPASS, whose objective it is to prepare for rocket  launch in spring 2024. Specifically, the goal of this project is the following:</p> <ul> <li>Integrate and develop testing for Kamlan Filter</li> <li>Integrate projcet with FRAM data bus</li> <li>Have a recovery system for SD-Card data in case of system failure</li> <li>Record/calculate apogee of rocket, and set recovery flag for Recovery Project ... among others</li> </ul> <p>Further details about each goal is or will be documentated further, as well as visualization of how the  project is strung together. Additionally we have in-depth instructions on how we structure and write our code. </p> <p>For further questions, contact Brage, Felix or H\u00e5kon.</p>"},{"location":"memor/#project-layout","title":"Project layout","text":"<pre><code>?\n</code></pre>"},{"location":"memor/#system-architecture","title":"System architecture","text":""},{"location":"about/conventions/","title":"Coding Conventions for Our Project","text":""},{"location":"about/conventions/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Variables</li> <li>Loops</li> <li>If Statements</li> <li>Methods, Functions and Returns</li> </ul>"},{"location":"about/conventions/#variables","title":"Variables","text":"<p>Variable conventions are quite easy to adhere to, but can make a massive difference in how how simple it is to understand code.</p> <p>This is how we declare and use variables:</p> <pre><code>//Normal variable in \"normal\" scope are camelCase\nint thisIsLocalScope;\n\n//It is very useful to separate between local scope variables and \n//member variables, and therefore we write member variables like this, \n//to easily point them out in a sea of calulations\nfloat m_memberVariable;\n\n//This is a constant\nfloat PI = 3.14;\n</code></pre> <p>We also highly value descriptive variable names. In Portal Space, the \"lifespan\" of a member is shorther than a normal company, as we move on after our studies. Therefore we must keep in mind that someone will take over our codebase in relatively short time.</p> <p>If that is not motivation enough for you, try to recall a time you looked back at your own code a month later, and all meaning is lost. Too many times I have been annoyed over my own lazy variable naming conventions</p> <p>Here are some examples: <pre><code>int num = list.length();\n//We already know an integer is a number, what does the number represent? \n// Even though the declaration confirms it is the length of a list, \n//we do not  want to have to look at the declaration of the variable \nevery time we interact with it. \n\n//We can also tell that the name of the list is lackluster. A list of what? -&gt;\nint numberOfEmployees= employees.length();\n\n\n//A bool is often represented as a state of a process, and is used as a check \n//before proceeding with other code, make sure the name of the bool is clear\n//in what it represents.\n\n//Avoid prefixes, they make us think for too long\nif (notDone)\n{\n  //When does this get called? \n  foo();\n}\n\nif (status)\n{\n  // What does 'true' status mean? Is it good or bad? Active or inactive?\n  bar();\n}\n\n//A good example is this:\n\nif (nav.isRunning())\n{\n  //Here we can clearly tell if we reach this point of the code when the CPU is running\n  foo(); \n}\n</code></pre></p> <p>While we are on the topic of booleans, we have a convention of not using the explicit bool datatype, but rather an int.  An integer is false if it equals 0, true if it is non-zero. Negative numbers are non-zero, and evaluated to true. This  is for C++ and C specifically, and defer to documentation of other languages where you are not sure.</p> <pre><code>bool isRunning; //Good name, bad datatype\nint isRunning; //There we go!\n</code></pre>"},{"location":"about/conventions/#loops","title":"Loops","text":"<p>Loops are quite essential in any codebase, there are not very many different ways to format it, but we  prefer to keep the curly braces in line so we can clearly see the scope of the loop. This theme of the curly braces are repeated throughout the codebase</p> <pre><code>//Notice the spacing between the keywords 'for' and ';'\nfor (int i = 0; i &lt; num; i++)\n{\n    //Code goes in here\n}\n</code></pre>"},{"location":"about/conventions/#if-statements","title":"If-Statements","text":"<p>Same as with loops, we like to keep the curly braces in line as to avoid scope confusion.</p> <pre><code>//This\nif (condition)\n{\n  foo();\n}\nelse\n{\n  bar();\n}\n\n//Not this:\nif (condition) {\n  foo();\n} else {\n  bar();\n}\n</code></pre> <p>A very important concept is to avoid indentation as much as possible. If you have several layers of indentation, reconsider your code and try to exit out of loops early.</p> <p>Suppose we have a function that checks if a user has access: <pre><code>void checkAccess(User user, Resource resource)\n{\n    if (user.isAuthenticated())\n    {\n        if (user.isActive())\n        {\n            if (user.hasRole(resource.requiredRole()))\n            {\n                if (!user.accessExpired(resource))\n                {\n                    // Grant access\n                }\n                else\n                {\n                    // Access expired\n                }\n            }\n            else\n            {\n                // Role mismatch\n            }\n        }\n        else\n        {\n            // User is not active\n        }\n    }\n    else\n    {\n        // User is not authenticated\n    }\n}\n</code></pre> As soon as we are a couple indentations too deep, we have way to many variables to keep track of, and  the control flow is way more complex than it needs to be.</p> <p>This is the code refactored, where we try to return early, and handle general cases early. This flattens the  indentations, and makes the code easier to skim over and understand: <pre><code>void canAccess(User user, Resource resource)\n{\n    if (!user.isAuthenticated())\n    {\n        // User is not authenticated\n        return;\n    }\n\n    if (!user.isActive())\n    {\n        // User is not active\n        return;\n    }\n\n    if (!user.hasRole(resource.requiredRole()))\n    {\n        // Role mismatch\n        return;\n    }\n\n    if (user.accessExpired(resource))\n    {\n        // Access expired\n        return;\n    }\n\n    // Grant access\n}\n</code></pre> Immediately we can tell how much easier this is to read and understand in a few glances. It is also beneficial when it comes to debugging, as the control flow is easier and we can tell which condition is not being met faster</p>"},{"location":"about/conventions/#methods-functions-and-returns","title":"Methods, Functions and Returns","text":"<p>Methods and functions have pretty much the same conventions as conditions and loops. We try to keep the function/method as flat as possible, with curly-braces in line and early returns to avoid complex control flow.</p> <p>Additionally, we try to errorproof our code, or at the very last make it clear when we reach an error or not.</p> <pre><code>int canAccess(User user, Resource resource)\n{\n    if (!user.isAuthenticated())\n    {\n        // User is not authenticated\n        printf(\"User is not authenticated\");\n        return 0;\n    }\n\n    if (!user.isActive())\n    {\n        // User is not active\n        printf(\"User is not active\");\n        return 0;\n    }\n\n    if (!user.hasRole(resource.requiredRole()))\n    {\n        // Role mismatch\n        printf(\"User does not have required role\");\n        return 0;\n    }\n\n    if (user.accessExpired(resource))\n    {\n        // Access expired\n        printf(\"User access has expired\");\n        return 0;\n    }\n\n    // Grant access\n    return 1;\n}\n</code></pre> <p>Above we had almost the exact same function as in the proper condition example, except we have added a few perks to make it easier to work with.</p> <ul> <li>Returns a value that indicates if it has gone successfully</li> <li>Prints an error message so we can see what conditions fails first</li> </ul> <p>The return 0 and return 1 are very useful, so we can call the function in a condition, and go from there. </p> <pre><code>if (!canAccess(arg1, arg2))\n{\n  //Means to handle the case of not accessing\n}\n\n//Continue code as expected when granted access...\n</code></pre> <p>Another alternative is to avoid explicitely printing the error message, and give the option instead. Imagine canAccess is a method, and the class it is within has an std::string m_CurrentErrorMessage</p> <p>Notice the correct naming convention of the method and the error message, that make them easy to work with.</p> <p>We use the first condition as an example: <pre><code>if (!user.isAuthenticated())\n    {\n        // User is not authenticated\n        setError(\"User is not authenticated\");\n        return 0;\n    }\n</code></pre></p> <p>And then where we call the method, we can choose whether we print the error or not:</p> <pre><code>if (!(client.canAccess(arg1, arg2)))\n{\n  printf(\"%s\", client.getError.c_str());\n  //Handle further\n\n}\n\n//Continue code as expected when granted access...\n</code></pre>"},{"location":"about/conventions/#classes","title":"Classes","text":"<p>There are many conventions that can be followed to make working with classes easier. This is one of hundreds of ways to make classes easy to read and work with.</p> <p>Below is a live class used in the current project, being the SDCard class, that handles pretty much everything to do with the SDCard.</p> <p>We use #pragma once over header guards, as they are less lines of code, looks prettier and is overall less error prone.</p> <p>In this case, we have a the class wrapped in a namespace, as to not mix common method names, like update with other classes</p> <p>We put public methods followed by public variables at the top. When inspecting a class that you are  unfamiliar with, ordering the public methods and variables first immediately gives you the contents of the class you can directly interact with</p> <p>We have good reason for why some methods and variables are private and some public. The most obvious is  to keep the class safe from outside interference. The other is the layer of abstraction. In this class we have an event driven system. Because of the layout of the class, the callee of the class only needs to call the classes constructor, and the update method at a certain interval. Those two methods take care of all the internal usage of the class, and we dont need to call any other methods.</p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n\nnamespace utils {\n\nclass SDCard {\n\n  enum SDCARD_STATE {\n    WAIT_SWITCH_PRESS = 0, // Waits for a switch to be pressed to activate SD_Card\n    OPEN_FILE,\n    WRITE_TO_FILE,\n    CLOSE_FILE,\n    IDLE,\n    ERROR\n  };\n\npublic:\n  // Methods\n  SDCard();\n  int update();\n  std::string getError() { return m_CurrentErrorString; }\n\npublic:\n  // Variables\n\nprivate:\n  // Methods\n  int init(); // Initializes SD_Card\n\n  // Methods to be called upon certain states\n  int waitSwitchPress();\n  int mountDisk();\n  int openFile();\n  int writeToFile();\n  int continueLog();\n  int closeFile();\n  int setIdle();\n  int setError(std::string errorMessage);\n\n  int logComplete() { return m_LogComplete; }\n\nprivate:\n  // Variables\n  SDCARD_STATE m_CurrentState;\n  std::string m_CurrentErrorString = \"\";\n\n  int m_LogComplete;\n};\n\n} // namespace utils\n</code></pre>"},{"location":"devlog/","title":"Feed","text":""},{"location":"devlog/2023/11/20/week42-2023/","title":"Week42 2023","text":""},{"location":"devlog/2023/11/20/week42-2023/#very-first-dev-log-and-cameras","title":"Very first dev-log (and cameras)","text":"<p>Pretty late into the development stage of the engine, I've finally gotten around to starting on documentation. The goal of documentation is to offcourse delve into how to use the engine, but the dev-log specifically is more about documenting my thought proccess, and the why to each decision. I think this will make the engine be easier to understand, and also give my future self my past viewpoint. Eventually, stuff in this engine will probably seem archaic, stupid and doomed to fail in my own eyes, as this is a common thing to happen to developers. Therefore, having my past (or right now, my current)  stupid self to go off of, will help.</p>"},{"location":"devlog/2023/11/20/week42-2023/#cameras","title":"Cameras","text":"<p>Cameras are a pretty difficult thing, as making one good camera to be used, is impossible. Creating a class that is easy to inherit from and easy to customize, I personally  think is the best course of action. Each game will have their very own perfect camera, and I cannot possibly make, or even imagine them all myself. So for now, my camera system will be  an abstract class called Camera, and a couple other classes that inherhit from said Camera, and implements a basic one. In my own game, that will be used to show off the features of the engine will possibly have a more advanced camera, so if you'd like you can look there for more inspiration on how to implement cameras in Memor.</p> <p>Cameras are also just built on top of SFML, so if you would like complete freedom, you can make your very own Camera class, and use that. </p> <p>(Fun fact, I am writing this dev-log during my math exam. Nuthin else to do) </p>"},{"location":"devlog/2023/11/20/week42-2023/#abstract-camera","title":"Abstract Camera","text":"<p>Here is THE abstract camera class that all other cameras are based on. Pretty simple I would say. My goal was to have it as simple as possible, so each user can implement their own cameras if they'd like.</p> <pre><code>#include \"../entity/ecs.hpp\"\n#include \"../math/math.hpp\"\n#include &lt;SFML/Main.hpp&gt;\n\nclass Camera {\npublic:\n  // Methods\n  Camera(math::vec2 position, math::vec2 size);\n  Camera(math::vec2* ent, math::vec2 size);\n  Camera(math::vec2* ent, math::vec2 size, float rotation);\n  Camera(math::vec2 position, math::vec2 size, float rotation);\n  Camera(math::vec2 position, float roation);\n\n  virtual void cameraUpdate() = 0;\n\n  float getRotation() { return m_Rotation; }\n  void setRotation(float rotation) { m_Rotation = rotation; };\n\n  math::vec2 getSize() { return m_Size; }\n  void setSize(math::vec2 size) { m_Size = size; }\n\n  math::vec2 setPosition() { return m_Position; }\n  void getPosition(math::vec2 position) { m_Position = position; }\n\n  void setEntity(math::vec2* ent) { m_EntityToFollow = ent; }\n\n  void shake(float duration, float intensity);\n\nprivate:\n  // Methods\n\npublic:\n  // Variables\n\nprivate:\n  // Variables\n  math::vec2 m_Position;\n  math::vec2 m_Size;\n  float m_Rotation;\n\n  math::vec2* m_EntityToFollow;\n};\n</code></pre>"},{"location":"devlog/archive/2023/","title":"2023","text":""},{"location":"devlog/category/devlog/","title":"devlog","text":""}]}