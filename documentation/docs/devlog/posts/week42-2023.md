---
draft: false 
date: 2023-11-20
categories:
    - devlog
---

### Very first dev-log (and cameras)

Pretty late into the development stage of the engine, I've finally gotten around to starting on documentation. The goal of documentation
is to offcourse delve into <er>how</er> to use the engine, but the dev-log specifically is more about documenting my thought proccess, and the <er>why</er>
to each decision. I think this will make the engine be easier to understand, and also give my future self my past viewpoint. Eventually, stuff in this engine will
probably seem archaic, stupid and doomed to fail in my own eyes, as this is a common thing to happen to developers. Therefore, having my past (or right now, my current) 
stupid self to go off of, will help.

### Cameras

Cameras are a pretty difficult thing, as making <er>one</er> good camera to be used, is impossible. Creating a class that is easy to inherit from and easy to customize, I personally 
think is the best course of action. Each game will have their very own perfect camera, and I cannot possibly make, or even imagine them all myself. So for now, my camera system will be 
an abstract class called Camera, and a couple other classes that inherhit from said Camera, and implements a basic one. In my own game, that will be used to show off the features of the
engine will possibly have a more advanced camera, so if you'd like you can look there for more inspiration on how to implement cameras in Memor.

Cameras are also just built on top of SFML, so if you would like complete freedom, you can make your very own Camera class, and use that. 

(Fun fact, I am writing this dev-log during my math exam. Nuthin else to do) 


### Abstract Camera

Here is THE abstract camera class that all other cameras are based on. Pretty simple I would say. My goal was to have it as simple as possible, so each user can implement their own cameras if they'd
like.

```cpp
#include "../entity/ecs.hpp"
#include "../math/math.hpp"
#include <SFML/Main.hpp>

class Camera {
public:
  // Methods
  Camera(math::vec2 position, math::vec2 size);
  Camera(math::vec2* ent, math::vec2 size);
  Camera(math::vec2* ent, math::vec2 size, float rotation);
  Camera(math::vec2 position, math::vec2 size, float rotation);
  Camera(math::vec2 position, float roation);

  virtual void cameraUpdate() = 0;
  
  float getRotation() { return m_Rotation; }
  void setRotation(float rotation) { m_Rotation = rotation; };

  math::vec2 getSize() { return m_Size; }
  void setSize(math::vec2 size) { m_Size = size; }

  math::vec2 setPosition() { return m_Position; }
  void getPosition(math::vec2 position) { m_Position = position; }

  void setEntity(math::vec2* ent) { m_EntityToFollow = ent; }

  void shake(float duration, float intensity);

private:
  // Methods

public:
  // Variables

private:
  // Variables
  math::vec2 m_Position;
  math::vec2 m_Size;
  float m_Rotation;

  math::vec2* m_EntityToFollow;
};
```

